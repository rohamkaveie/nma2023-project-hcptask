import torch
import torch.nn as nn
import torchvision.models as models

# Load the pre-trained ResNet50 model
resnet = models.resnet50(pretrained=True)

# Freeze the weights of the pre-trained layers
for param in resnet.parameters():
    param.requires_grad = False

# Replace the last fully connected layer for binary classification
num_features = resnet.fc.in_features
resnet.fc = nn.Linear(num_features, 1)

# Define the loss function and optimizer
criterion = nn.BCEWithLogitsLoss()
optimizer = torch.optim.Adam(resnet.parameters(), lr=0.001)

# Train the model with your data
train_data = ...  # Your training data
train_labels = ...  # Your training labels

num_epochs = 10
batch_size = 32

for epoch in range(num_epochs):
    for i in range(0, len(train_data), batch_size):
        inputs = train_data[i:i+batch_size]
        labels = train_labels[i:i+batch_size]

        optimizer.zero_grad()

        outputs = resnet(inputs)
        loss = criterion(outputs.squeeze(), labels.float())
        loss.backward()
        optimizer.step()

    print(f"Epoch {epoch+1}/{num_epochs}, Loss: {loss.item()}")

# Make predictions on new data
test_data = ...  # Your test data

with torch.no_grad():
    resnet.eval()
    outputs = resnet(test_data)
    predictions = torch.sigmoid(outputs).squeeze().tolist()

# Print the predicted classes
predicted_classes = [1 if pred > 0.5 else 0 for pred in predictions]
print(predicted_classes)